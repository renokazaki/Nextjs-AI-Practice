# Nextjsベストプラクティスチェック

# 基本ルールとディレクトリ構成

## コード品質の担保

プルリクエスト提出前には、必ず以下のチェックを実施します。

```
Prettierによるフォーマット
ESLintによる静的解析
TypeScriptの型エラーチェック
ビルドエラーの確認
```

必要であればciを実装して確認しても良いかも

## ディレクトリ構成

続いて、ディレクトリ構成についてご紹介します。
Next.jsのファイルベースルーティングとコロケーションパターンに準拠したディレクトリ構成を採用します。

基本方針はNext.jsのファイルベースルーティングとコロケーションパターンに準拠し、画面・機能固有のファイルは、対応するpage.tsxと同階層のディレクトリに配置し、複数箇所で使用するファイルは、appと同階層のディレクトリ内に配置します。

認証が必要ない画面は静的レンダリングになることが多いので、Full Route Cache（≒SSG）を確実に適用させるためにも、分けておいた方が良いと考えています。

```
src/
├─ app/                          // 画面・機能単位
│  ├─ (private)/                 // ログイン必須
│  │  ├─ actions/                // 固有Server Actions
│  │  ├─ apis/                   // 固有APIクライアント
│  │  ├─ components/             // 固有コンポーネント
│  │  ├─ constants/              // 固有定数
│  │  ├─ hooks/                  // 固有カスタムフック
│  │  ├─ stores/                 // 固有ストア（単一画面内だが階層が深く、複数コンポーネントで共有するようなデータ管理）
│  │  ├─ providers/              // 固有プロバイダー
│  │  ├─ schemas/                // 固有スキーマ
│  │  ├─ types/                  // 固有型定義
│  │  ├─ utils/                  // 固有ユーティリティ関数
│  │  └─ layout.tsx              // private用レイアウト
│  │
│  ├─ (public)/                  // ログイン任意
│  │  └─ layout.tsx              // public用レイアウト
│  │
│  └─ api/                       // Route Handlers（クライアントフェッチのBFF用）
│
├─ actions/                      // 汎用Server Actions
├─ apis/                         // 汎用APIクライアント
├─ components/                   // 汎用コンポーネント
├─ constants/                    // 汎用定数
├─ hooks/                        // 汎用カスタムフック
├─ stores/                       // グローバルストア
├─ providers/                    // 汎用プロバイダー
├─ lib/                          // ライブラリ関連
├─ schemas/                      // 汎用スキーマ
├─ types/                        // 汎用型定義
└─ utils/                        // ユーティリティ関数
```

## ファイル・ディレクトリの命名規則

ディレクトリ・ファイル名の基本ルールは以下の通りです。

対象 命名規則 例
| 対象 | 命名規則 | 例 |
|------|----------|-----|
| app配下のルーティングになるディレクトリ | ケバブケース | user-profile/, search-results/ |
| コンポーネントのファイル | アッパーキャメルケース | UserProfile.tsx, SearchForm.tsx |
| その他のディレクトリ・ファイル | キャメルケース | fetchUser.ts, userSchema.ts |

app配下のルーティングになるものは、Google検索におけるURL構造のベストプラクティスに沿ってケバブケースにします。

また、ファイル名はJavaScriptの慣習に沿ってキャメルケースにし、コンポーネントはReactのルールに沿ってアッパーキャメルケースとします。

# コンポーネント設計

1. 単一責任の原則
   コンポーネントは、UI・ロジック・状態管理・データハンドリングなど、なるべく複数の責務を混在させないようにします。関心の分離を徹底することで、テストしやすく、再利用しやすいコンポーネントが実現できます。

2. YAGNIの原則
   「You Aren't Gonna Need It（それは必要にならない）」の原則に従い、早すぎる抽象化や過度な分割はコスト増になるため避けます。必要になってから対応することで、過剰な設計を防ぎます。

将来を見越した設計も重要ですが、現在の要件に集中し、必要になった時点でリファクタリングする方が、結果的にシンプルで保守しやすいコードになります。

行数での分割基準と理想の分布
コンポーネントの行数による分割基準と、理想的な分布を以下の表に示します。

| 行数範囲   | 理想割合（目標） | コメント                                                 |
| ---------- | ---------------- | -------------------------------------------------------- |
| 1〜100行   | 70〜80%          | ゴールデンゾーン。多くのコンポーネントはこの範囲に収める |
| 101〜200行 | 15〜25%          | 複雑UI（フォーム・モーダル・詳細画面など）               |
| 201〜300行 | 0〜5%            | 外れ値扱い。レビュー時に分割候補を確認                   |
| 300行超    | 0%               | 原則禁止。発生したら即分割検討                           |

この分布を目指すことで、コンポーネントの可読性と保守性を維持できます。

その他の分割基準
以下の場合も分割を検討します。

| 分割基準                                 | 対応方針                                     |
| ---------------------------------------- | -------------------------------------------- |
| 条件分岐後のUI（HTML）が30行以上         | 条件分岐ごとにコンポーネントを分割           |
| 同系UIの繰り返し（リスト行やカードなど） | 繰り返し部分をコンポーネント化               |
| Hook呼び出しが6個以上                    | 関連する内容をカスタムフックとして切り出し   |
| 関連ロジックだけで30〜40行以上           | カスタムフックやユーティリティ関数に切り出し |
| onClickなどのイベントハンドラが5個以上   | カスタムフックやユーティリティ関数に切り出し |

これらの基準を参考に、コンポーネントの肥大化を防ぎます。

# Server Componentのルール

page.tsxは同期かつサーバーコンポーネントに
page.tsxは同期かつサーバーコンポーネントにし、サスペンドさせません。つまり、基本的にawaitやuseは使用しません。

```
page.tsxを同期かつサーバーコンポーネントにする理由
拡張性の確保

page.tsxを同期にすることで、将来的な要件変更（初期描画を高速化したい・データ取得が必要になったなど）や追加機能の適用（PPRなど）などに柔軟に対応できます。

PPR（Partial Prerendering）への対応

Partial Prerenderingを活用する際、page.tsxを同期にしておくことで、静的部分と動的部分の分離がしやすくなります。

JavaScriptバンドルサイズの削減

Server Componentを使用することで、クライアントに送信するJavaScriptバンドルサイズを削減できます。page.tsxをサーバーコンポーネントにすることで、この恩恵を最大化します。

テンプレート的な立ち位置

page.tsxをテンプレート的な立ち位置にし、トップを安易に非同期化しないことで、ページ全体の構造が明確になります。

ただし、awaitなしでサーバーフェッチをキックし、子コンポーネントにPromiseのまま渡すのは問題ありません。
```

## エラーUIの出し分け

Server Componentでのフェッチ結果によるエラーUIの出し分けは、コンポーネント内に記述します。コンポーネント内で部分的にエラーUIを表示することで、ページ全体がエラー画面になることを防ぎます。

# Client Componentのルール

Client Componentは必要最小限に
Client Componentは必要最小限の部分のみに分割し、基本的にServer Componentを使用します。

Client Componentが必要なのは以下のような場合です。

| 条件                               | 具体例                                  |
| ---------------------------------- | --------------------------------------- |
| ユーザーインタラクションがある部分 | ボタンのクリックやフォームの入力など    |
| ブラウザAPI使用箇所                | localStorage や window オブジェクトなど |
| React Hooksを使用する箇所          | useState や useEffect など              |

# その他

## Compositionパターンの活用

Client Component配下にServer Componentをネストさせる場合、直接importせず、Client ComponentのchildrenでServer Componentを渡すCompositionパターンを使います。

## default exportで統一

基本的にコンポーネントは default export に統一します。

Next.js 標準のコンポーネント（page.tsx や layout.tsx、loading.tsx など）が default export を採用しているため、それに合わせてプロジェクト全体で一貫性を保つためです。

# データ

1. Server Componentで直接外部APIをfetch
   Server Componentで直接外部APIをfetchし、シンプルに実装するのが第一優先です。

2. クライアントフェッチはTanStack QueryとRoute Handlerを使用
   クライアントフェッチの場合は、TanStack Queryを使用し、必ずRoute Handlerを経由して外部APIを叩きます。

```
TanStack QueryとRoute Handlerを経由する理由
機密情報の保護

クライアントから直接外部APIを叩くと、APIキーやトークンがクライアントに露出してしまいます。Route Handlerを経由することで、これらの機密情報をサーバー側に隠蔽できます。

クライアントキャッシュに強い

Next.jsはData CacheやRequest Memoization、Full Route Cacheなど、サーバー側でのキャッシュには強いですが、クライアント側のキャッシュには弱いです。（Router Cacheはありますが、、、）

一方、TanStack Queryはリモートデータにおけるクライアントキャッシュに強く、シンプルに使うことも、複数画面でキャッシュデータを共有するようなことも可能なため、クライアントフェッチにおけるキャッシュやデータ管理はTanStack Queryに委任します。
```

3. データフェッチコロケーション
   基本的にデータが必要なコンポーネントで直接フェッチをします。

```
データが必要な場所で直接取得することでコンポーネントの独立性が向上し、その結果再利用性が高まります。

また、親コンポーネントからpropsでデータを子孫コンポーネントへ渡すようなProps Drillingのデメリットが解消されることもメリットです。

データフェッチコロケーションが実現できる理由
Next.js 15では、Request Memoizationというキャッシュ機能が同一レンダー内の重複取得を自動排除します。そのため、複数のコンポーネントで同じデータを取得しても、実際のリクエストは1回のみになります。
```
